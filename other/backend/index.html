<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>index.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1>Documentation of the Backend part</h1>

<blockquote><p>Deliverable D1</p></blockquote>

<h2>General group information</h2>

<table>
<thead>
<tr>
<th> Member n. </th>
<th> Role </th>
<th> First name </th>
<th> Last Name </th>
<th> Matricola </th>
<th> Email address </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> administrator </td>
<td> Luca </td>
<td> Maltagliati </td>
<td> 919858 </td>
<td> luca.maltagliati@mail.polimi.it </td>
</tr>
<tr>
<td> 2 </td>
<td> member </td>
<td> Marco </td>
<td> Turetta </td>
<td> 921188 </td>
<td> marco3.turetta@mail.polimi.it </td>
</tr>
<tr>
<td> 3 </td>
<td> member </td>
<td> Alessandro </td>
<td> Carughi </td>
<td> 915626 </td>
<td> alessandro.carughi@mail.polimi.it </td>
</tr>
</tbody>
</table>


<h2>Links to other deliverables</h2>

<ul>
<li>Deliverable D0: the web application is accessible at
<a href="https://bookhub-ctm.herokuapp.com/">this
address</a>.</li>
<li>Deliverable D2: the YAML or JSON file containing the specification of the app
API can be found at <a href="https://bookhub-ctm.herokuapp.com/backend/spec.yaml">this
address</a>.</li>
<li>Deliverable D3: the SwaggerUI page of the same API is available at
<a href="https://bookhub-ctm.herokuapp.com/docs">this
address</a>.</li>
<li>Deliverable D4: the source code of D0 is available as a zip file at
<a href="https://bookhub-ctm.herokuapp.com/backend/app.zip">this address</a>.</li>
<li>Deliverable D5: the address of the online source control repository is
available <a href="https://github.com/malta895/hypermedia-project/">this
address</a>.
We hereby declare that this
is a private repository and, upon request, we will give access to the
instructors.

<h2>Specification</h2>

<h3>Web Architecture</h3>

<p>Describe here, with a diagram, the components of your web application and how
they interact. Highlight which parts belong to the application layer, data layer
or presentation layer. How did you ensure that HTML is not rendered server side?</p></li>
</ul>


<p>TODO inserire immagine <a href="components.png"></a></p>

<p>Our web application serves statically the folder containing the html pages and other assets such as scripts, images and style sheets; all the other data is produced by the backend in JSON format, then is retrieved and rendered on the pages by the client JavaScript code. By following this pattern we are sure that HTML code is never rendered server-side.</p>

<h3>API</h3>

<h4>REST compliance</h4>

<p>Describe here to what extent did you follow REST principles and what are the
reasons for which you might have decided to diverge. Note, you must not describe
the whole API here, just the design decisions.</p>

<p>We did follow the following REST principles:</p>

<ul>
<li><p><strong>Statelessness</strong>: Every requst contains all the informations needed to perform the request. There are some request who require authentication: in this case the client must send the cookie containing the session token to authenticate himself.</p></li>
<li><p><strong>Uniform interfaces</strong>: Every component in the web server always follow the same rules to communicate with another: in our project, controllers always call the corresponding method on the corresponding services, retrieve the data, call the JSON generator function that finally sends data to the client. All the URIs follow the same naming convention (for example, all requests regarding books start with /books, and so on), response codes follow HTTP conventions (200 for succesful response, 404 when resource is not found, 401 if the client fails authorization and so on so forth) and finally all the requests methods are coherent with the actual operation carried out when this specific request is invoked, as specified by <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP methods conventions</a>.</p></li>
<li><p><strong>Layered System</strong>: Every component interacts transparently to the others: also, every component has its well-defined task: the modularity of the application obtained in this way makes it easier to understand and to extend or modify the single components of the systems without worrying about the others.</p></li>
<li><p><strong>Client-Server</strong>: Client and server can evolve separately: there is no dependency on the technologies used under the hood in these two components; client only knows URIs to get the resources and server sends them transparently with a standard representation (JSON in our case).</p></li>
</ul>


<h4>OpenAPI Resource models</h4>

<p>Describe here synthetically, which models you have introduced for resources.</p>

<h3>Data model</h3>

<p>Describe with an ER diagram the model used in the data layer of your web
application. How these map to the OpenAPI data model?</p>

<h2>Implementation</h2>

<h3>Tools used</h3>

<p>Describe here which tools, languages and frameworks did you use for the backend
of the application.</p>

<p>We used Swagger framework to generate the OpenAPI specs and code skeleton of our web server.
The backend is written in JavaScript on NodeJS version 10.6.</p>

<p>Among the others, we used the following npm packages:</p>

<ul>
<li><p>[express][https://www.npmjs.com/package/express], to route the requests to the server</p></li>
<li><p><a href="https://www.npmjs.com/package/express">express-session</a>, to manage session and authenti
cation with cookies;</p></li>
<li><p><a href="https://knexjs.org/">KnexJS</a>, to build queries and to interface to the database;</p></li>
<li><p><a href="https://www.npmjs.com/package/bcrypt">bcrypt</a>, to encrypt password and store their hashed representation on the database;</p></li>
<li><p><a href="https://www.npmjs.com/package/bluebird">bluebird</a>, an alternative <em>Promise</em> implementation;</p></li>
<li><p><a href="https://www.npmjs.com/package/sanitize-html">sanitize-html</a>, to clean input text from potentially dangerous HTML (and JavaScript) code, as a countermeasure towards CSRF and XSS attacks.</p></li>
</ul>


<h3>Discussion</h3>

<p>Describe here:
- How did you make sure your web application adheres to the provided OpenAPI
specification?</p>

<ul>
<li><p>Why do you think your web application adheres to common practices to partition
the web application (static assets vs. application data)</p></li>
<li><p><strong>Describe synthetically why and how did you manage session state, what are the
state change triggering actions (e.g., POST to login etc..)</strong></p></li>
</ul>


<p>For managing session we used the npm package express-session, which transparently allows to generate a cookie based session by providing a secret string used to encrypt the cookie. A session object is then provided, we wrote a wrapper around it with getters and setters, to avoid conflicts while modifying it.</p>

<ul>
<li><strong>Which technology did you use (relational or a no-SQL database) for managing
the data model?</strong></li>
</ul>


<p>We used the ORDBMS database PostgreSQL, as suggested by our backend instructor.
We exploited many functionalities offered by this system, by making extensive use of triggers and views. We decided to adopt this approach for three main reasons:
- Triggers, constraints and foreign keys guarantee coherence of data, avoiding the introduction of errors after inserting or updating rows.
- Some of the business logic is moved to the database, where operations are more efficient.
- Views make the queries more simple and readable, avoiding long and repetitive queries in the services scripts.</p>

<p>We interfaced it to the NodeJS environment using the <a href="https://knexjs.org/">Knex.js</a> library.</p>

<h2>Other information</h2>

<h3>Task assignment</h3>

<!-- Describe here how development tasks have been subdivided among members of the -->


<!-- group, e.g.: -->


<!-- - Foo worked on front end (80%) and OpenAPI Spec (20% of the time) -->


<!-- - Bar worked on .... -->


<ul>
<li>Luca: Worked on back-end and OpenAPI Specs 70% of the time; front-end scripts and rendering 30% of the time</li>
<li>Marco: Worked on backend and OpenAPI Specs 20% of the time, front-end scripts and rendering 70%, documentations 10%</li>
<li>Alessandro: Worked on front-end 70% of the time, documentations and site evaluation 30% of the time.</li>
</ul>


<h3>Analysis of existing API</h3>

<p>Describe here if you have found relevant APIs that have inspired the OpenAPI specification and why (at least two).</p>

<h3>Learning outcome</h3>

<p>What was the most important thing all the members have learned while developing
this part of the project, what questions remained unanswered, how you will use
what you&rsquo;ve learned in your everyday life?</p>

<p>Luca: In this course I learned to use technologies I have never used before: NodeJS, Swagger and PostgreSQL. I am sure they could be useful in a future job.</p>

</body>
</html>
